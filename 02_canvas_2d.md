
<!--- file: 02_canvas_2d.md --->

[[ Оглавление ]](README.md)

# Урок №2: Инструментарий. Canvas 2D и создание своей базовой графической библиотеки.

## Введение: Почему именно браузер и Canvas?

Компьютерная графика — это область, где теория неразрывно связана с практикой. Чтобы глубоко понять алгоритмы растеризации, преобразований и визуализации, необходимо не только изучать формулы, но и наблюдать их в действии. Для этого нужна среда, которая позволяет быстро запускать и изменять код, не требует сложной настройки окружения, даёт прямой доступ к пикселям и работает на как можно большем количестве устройств.

Исторически для изучения графики использовались разные подходы:

* **C/C++ с SDL2** — мощный и производительный, но требует компиляции, установки библиотек и отладки среды, что замедлит обучение теории алгоритмов.
* **Python с Pygame** — удобен для прототипирования, но интерпретируемый код может быть медленным для пиксельных операций, а установка зависимостей — лишний барьер.
* **Lua с LÖVE** — элегантный и лёгкий, но менее распространён и требует дополнительного ПО.

**Наш выбор — JavaScript и Canvas 2D API.**

Это решение даёт уникальный баланс:

* **Нулевой порог входа**: нужен только браузер — никаких установок, компиляций или настроек.
* **Мгновенная обратная связь**: обновил страницу — увидел результат.
* **Доступ к пикселям**: через `ImageData` можно напрямую управлять цветом каждого пикселя — именно это нам нужно для реализации алгоритмов.
* **Кроссплатформенность**: работает на Windows, macOS, Linux, планшетах и даже смартфонах.

Важно понимать: алгоритмы, которые мы будем реализовывать, универсальны. Они не зависят от языка или API — будь то Canvas, OpenGL, Vulkan или DirectX. Освоив алгоритмы в одной среде, вы сможете перенести знания в любую другую. И мы обязательно перенесем полученный опыт на более низкоуровневые инструменты работы с графикой.


## Canvas 2D: Возможности и ограничения

**Canvas 2D** — это мощный, но простой инструмент. Он предоставляет два уровня доступа к графике:

### 1. Высокоуровневый API

Позволяет рисовать линии, прямоугольники, круги и текст, что идеально для отладки, интерфейсов и быстрых набросков.

### 2. Низкоуровневый доступ через ImageData

Даёт полный контроль над буфером пикселей — именно этот уровень мы будем использовать для реализации алгоритмов растеризации.

### Плюсы:

- Аппаратное ускорение в современных браузерах.
- Простой и интуитивный API.
- Поддержка как примитивов, так и пиксельных операций.

### Минусы:

- Нет встроенной сцены или системы объектов — всё состояние управляется вручную.
- Пиксельные операции выполняются в JavaScript — медленнее, чем в нативном коде, но достаточно быстро для учебных целей.


## Базовая инициализация Canvas

Вместо статического элемента в HTML мы создадим Canvas динамически — это удобнее для экспериментов и переиспользования.

```javascript

// 1. Создаём элемент Canvas
const canvas = document.createElement('canvas')
canvas.width = 800   // Ширина в пикселях
canvas.height = 600  // Высота в пикселях
canvas.style.border = '1px solid #333' // Для визуального контроля
document.body.appendChild(canvas)

// 2. Получаем 2D-контекст
const context = canvas.getContext('2d', { willReadFrequently: true })

// включение настройки willReadFreaquently включает оптимизацию для частой манипуляцией с пикселями

```

> **Совет**: стоит отключить оптимизации Canvas, рассчитанные на работу стандартного API
> * Отключаем сглаживание:
> ```javascript
> context.imageSmoothingEnabled = false
> ```
> * Добавляем в CSS для Canvas:  
> ```css
> canvas { image-rendering: pixelated; }
> ```  
> Это предотвратит размытие при масштабировании, что особенно важно при пиксель-арт графике и алгоритмах.


## Попиксельное рисование через ImageData

Чтобы работать с пикселями напрямую, мы используем объект `ImageData`, который содержит массив `data` — последовательность значений R, G, B, A для каждого пикселя.

Объект `ImageData` — это и есть наше цифровое полотно, самый низкий уровень доступа к изображению в Canvas. Давайте разберём его по косточкам.

### Свойства объекта ImageData

* `.data`: Самое главное свойство — объект типа `Uint8ClampedArray`. Это одномерный массив, содержащий данные о каждом пикселе изображения.
* `.width`: Ширина изображения в пикселях (только для чтения).
* `.height`: Высота изображения в пикселях (только для чтения).
* Конструктор: `new ImageData(width, height)` или `new ImageData(array, width)`.

### Структура массива .data: Почему это так важно?

Массив `.data` хранит информацию о цвете не в виде двумерной сетки `(X, Y)`, а в виде длинной-предлинной последовательности чисел. Это сделано для максимальной производительности.

Каждый пиксель кодируется четырьмя последовательными числами (байтами) в этом массиве:

* R — интенсивность красного (от 0 до 255)
* G — интенсивность зелёного (от 0 до 255)
* B — интенсивность синего (от 0 до 255)
* A — альфа-канал, непрозрачность (от 0 — полностью прозрачный, до 255 — полностью непрозрачный)

Таким образом, массив для изображения размером 2x2 пикселя будет выглядеть в памяти так:
[R0, G0, B0, A0, R1, G1, B1, A1, R2, G2, B2, A2, R3, G3, B3, A3]
Как найти нужный пиксель? Волшебная формула индекса

Чтобы получить доступ к пикселю с координатами `(x, y)`, необходимо рассчитать индекс первого байта `(R)` этого пикселя в одномерном массиве.

Формула выглядит так: `index = (y * imageWidth + x) * 4`

Разберём её по шагам на примере пикселя `(x=10, y=5)` на холсте шириной 800 пикселей:
* `y * imageWidth`: Мы находим, в какой строке находится наш пиксель. 5 * 800 = 4000. Это означает, что до начала 5-й строки мы уже прошли 4000 пикселей!
* `+ x`: Теперь мы идём по этой строке до нужного столбца. 4000 + 10 = 4010. Мы нашли порядковый номер пикселя в общем потоке.
* `* 4`: И, наконец, умножаем на 4, потому что каждый пиксель занимает 4 байта (R, G, B, A). 4010 * 4 = 16040. Это и есть индекс байта красной компоненты нашего пикселя в массиве .data!

Теперь мы знаем, что:
* .data[index] — это красный цвет (R)
* .data[index + 1] — это зелёный цвет (G)
* .data[index + 2] — это синий цвет (B)
* .data[index + 3] — это прозрачность (A)


### Пример использования

```javascript

// Создаём буфер пикселей
const imageData = ctx.createImageData(canvas.width, canvas.height)
const data = imageData.data // Uint8ClampedArray [R, G, B, A, R, G, B, A...]

// Функция для установки цвета пикселя
function putPixel(x, y, r, g, b, a = 255) {
    if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) return
    const index = (y * canvas.width + x) * 4
    data[index]     = r
    data[index + 1] = g
    data[index + 2] = b
    data[index + 3] = a
}

// Пример: закрашиваем пиксель в красный
putPixel(10, 10, 255, 0, 0);

// Отображаем изменения на экране
ctx.putImageData(imageData, 0, 0);
```

> **Важно**: вызов `putImageData` — дорогая операция. Старайтесь вызывать его **один раз за кадр**, после всех изменений.


## Создаём класс GC

Чтобы упростить работу и избежать дублирования кода, создадим класс `GC` (Graphics Context) — нашу собственную графическую библиотеку для курса.

```javascript

class GC {

    constructor(width, height) {
        // Создаём Canvas
        this.canvas = document.createElement('canvas')
        this.canvas.width = width
        this.canvas.height = height
        this.canvas.style.border = '1px solid #333'
        document.body.appendChild(this.canvas)

        // Получаем контекст с оптимизацией для частого чтения
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true })
        this.ctx.imageSmoothingEnabled = false

        // Создаём буфер пикселей
        this.imageData = this.ctx.createImageData(width, height)
        this.data = this.imageData.data
    }

    // Установка цвета одного пикселя
    putPixel(x, y, r, g, b, a = 255) {
        if (x < 0 || y < 0 || x >= this.canvas.width || y >= this.canvas.height) return
        const index = (y * this.canvas.width + x) * 4
        this.data[index]     = r
        this.data[index + 1] = g
        this.data[index + 2] = b
        this.data[index + 3] = a
    }

    // Очистка буфера заданным цветом
    clear(r = 0, g = 0, b = 0, a = 255) {
        for (let i = 0; i < this.data.length; i += 4) {
            this.data[i]     = r
            this.data[i + 1] = g
            this.data[i + 2] = b
            this.data[i + 3] = a
        }
    }

    // Обновление экрана — "blit" (блиттинг)
    blit() {
        this.ctx.putImageData(this.imageData, 0, 0)
    }
}
```

## Игровой цикл и requestAnimationFrame

Для анимации и интерактивности нам нужен цикл, синхронизированный с частотой обновления экрана. В браузере для этого используется `requestAnimationFrame`.

```javascript

const gc = new GC(800, 600)

let lastTime = 0
let fps = 0

function gameLoop(timestamp) {
    
    // Рассчитываем FPS
    const deltaTime = timestamp - lastTime
    lastTime = timestamp
    fps = Math.round(deltaTime ? 1000 / deltaTime : 1000)

    // 1. Очищаем буфер
    gc.clear(0, 0, 0) // Чёрный фон

    // 2. Рисуем что-то (например, движущуюся линию)
    const time = timestamp / 1000
    const x = 100 + 300 * Math.cos(time)
    const y = 300 + 200 * Math.sin(time)
    gc.drawLine(400, 300, x, y, 0, 255, 0) // Зелёная линия

    // 3. Выводим кадр на экран
    gc.blit()

    // 4. Отображаем FPS (используем высокоуровневый API для текста)
    gc.ctx.fillStyle = 'white'
    gc.ctx.font = '16px Monospace'
    gc.ctx.fillText(`FPS: ${fps}`, 10, 20)

    // 5. Запрашиваем следующий кадр
    requestAnimationFrame(gameLoop)
}

// Запускаем цикл
requestAnimationFrame(gameLoop)
```

> **Важно**: Концепция двойной буферизации  
> Мы рисуем всё в буфере `imageData`, а затем одним вызовом `blit()` выводим его на экран. Это предотвращает мерцание и обеспечивает плавную анимацию.


## Заключение

Мы создали собственную мини-библиотеку `GC`, которая даёт нам полный контроль над пикселями и позволяет реализовывать любые графические алгоритмы — от растеризации линий до заливки полигонов и текстурирования.  

Canvas 2D — не самая производительная среда, но идеальная для обучения: простая, доступная, визуально наглядная. Освоив принципы здесь, вы сможете легко перенести их на более сложные API — будь то WebGL, OpenGL или Vulkan.

В следующих лекциях мы начнём реализовывать первые алгоритмы: растеризацию линий, треугольников, работу с цветом и затенение — всё это будет строиться на основе нашего класса `GC`.

[[ Урок №1: Основы компьютерной графики, её история и используемые технологии. ]](01_the_basics.md)  
[[ Урок №3: Рисование линий и прямоугольников — первые шаги в растеризации. ]](03_lines_and_rects.md)
