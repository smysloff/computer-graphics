<!--- file: 07_active_edge_table.md --->

# Лекция №4: «Алгоритм Active Edge Table (AET) — оптимизация растеризации сложных полигонов».

## Структура

### Введение: Пределы наивного подхода.
* Почему наш текущий метод с постоянной интерполяцией неэффективен для сложных сцен с десятками полигонов?
* Постановка проблемы: Нам нужен алгоритм, который минимизирует вычисления на каждом сканирующей строке.

### Теория: Этапы алгоритма AET.
* Предварительная обработка: Global Edge Table (GET).
    * Разбираем все рёбра всех полигонов.
    * Сортируем их по Y_min (минимальной Y-координате).
    * Для каждого ребра храним: Y_max, X_min (X при Y_min), и 1/m (обратный угловой коэффициент, dx/dy).
* Основной цикл по сканирующим строкам (Y).
    * Начинаем с самого нижнего Y.
* Active Edge Table (AET): Список рёбер, которые активны для текущего Y (т.е. Y_min <= currentY < Y_max).
    * На каждом шаге Y:
        * Добавляем в AET все рёбра из GET, у которых Y_min == currentY.
        * Удаляем из AET все рёбра, у которых Y_max == currentY.
        * Сортируем AET по X! (Это ключевой момент).
        * Попарно обходим рёбра в AET и закрашиваем горизонтальные отрезки между ними.
        * Обновляем X для всех рёбер в AET: X += 1/m (это дешёвое сложение вместо дорогой интерполяции!).
    * Переходим к Y+1.

### Реализация: Пишем свой AET.
* Создадим класс Edge с полями yMax, xCurrent, slopeInverse.
* Создадим класс Polygon, который будет содержать массив рёбер.
* Реализуем методы для построения GET и обновления AET.
* Интегрируем всё в наш класс GC методом scanFillPolygon(polygon).

## Сравнение производительности.
* Демонстрация FPS для старого и нового метода на одном и том же сложном полигоне.
* Наглядное доказательство эффективности.

## Ограничения и нюансы.
* Работа с самопересекающимися полигонами.
* Вопросы точности из-за накопления ошибки при X += 1/m (и как это решать).
