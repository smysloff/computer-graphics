# Сравнение midpoint и Bresenham алгоритмов для растеризации прямых линий

Наглядное сопоставление ключевых строчек двух вариантов алгоритма построения линии: **без оптимизаций (с дробными вычислениями)** и **с оптимизациями (алгоритм Брезенхема с целочисленными вычислениями)**. Это поможет визуально увидеть, как именно происходит переход от "простой" реализации к эффективной.

---

### 1. Инициализация

| Без оптимизаций (с дробями)                         | С оптимизациями (целочисленный Брезенхем)                      |
|----------------------------------------------------|----------------------------------------------------------------|
| `deltaX = abs(x1 - x0)`                            | `deltaX = abs(x1 - x0)`                                        |
| `deltaY = abs(y1 - y0)`                            | `deltaY = abs(y1 - y0)`                                        |
| `acc = 0.0`  // накопленная ошибка (fractional)  | `error = 2 * deltaY - deltaX`  // целочисленная ошибка         |
| `x = x0`                                           | `x = x0`                                                       |
| `y = y0`                                           | `y = y0`                                                       |

---

### 2. Основной цикл (движение по большей оси)

Для каждого шага по X (если `deltaX > deltaY`):

| Без оптимизаций (с дробями)                                                                 | С оптимизациями (целочисленный Брезенхем)                                  |
|----------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| &nbsp;&nbsp;`x += signX`                                                                    | &nbsp;&nbsp;`x += signX`                                                   |
| &nbsp;&nbsp;`acc += deltaY / deltaX`  // добавляем дробное приращение                         | &nbsp;&nbsp;`error += 2 * deltaY`  // добавляем целочисленное приращение   |
| &nbsp;&nbsp;`if acc >= 0.5:`                                                                | &nbsp;&nbsp;`if error > 0:`                                                |
| &nbsp;&nbsp;&nbsp;&nbsp;`y += signY`                                                        | &nbsp;&nbsp;&nbsp;&nbsp;`y += signY`                                       |
| &nbsp;&nbsp;&nbsp;&nbsp;`acc -= 1.0`  // сбрасываем накопленную ошибку                       | &nbsp;&nbsp;&nbsp;&nbsp;`error -= 2 * deltaX`  // корректируем ошибку      |
| &nbsp;&nbsp;`plot(x, y)`                                                                     | &nbsp;&nbsp;`plot(x, y)`                                                   |

Для каждого шага по Y (если `deltaY > deltaX`):

| Без оптимизаций (с дробями)                                                                 | С оптимизациями (целочисленный Брезенхем)                                  |
|----------------------------------------------------------------------------------------------|----------------------------------------------------------------------------|
| &nbsp;&nbsp;`y += signY`                                                                    | &nbsp;&nbsp;`y += signY`                                                   |
| &nbsp;&nbsp;`acc += deltaX / deltaY`                                                        | &nbsp;&nbsp;`error += 2 * deltaX`                                          |
| &nbsp;&nbsp;`if acc >= 0.5:`                                                                | &nbsp;&nbsp;`if error > 0:`                                                |
| &nbsp;&nbsp;&nbsp;&nbsp;`x += signX`                                                        | &nbsp;&nbsp;&nbsp;&nbsp;`x += signX`                                       |
| &nbsp;&nbsp;&nbsp;&nbsp;`acc -= 1.0`                                                        | &nbsp;&nbsp;&nbsp;&nbsp;`error -= 2 * deltaY`                              |
| &nbsp;&nbsp;`plot(x, y)`                                                                     | &nbsp;&nbsp;`plot(x, y)`                                                   |

### 3. Итоговое сравнение

| Что делает без оптимизаций?                                | Что делает с оптимизациями?                              |
|------------------------------------------------------------|----------------------------------------------------------|
| Использует дробные приращения `acc += deltaY / deltaX`     | Использует целочисленную ошибку `error += 2 * deltaY`    |
| Сравнивает накопленную дробную ошибку с 0.5                | Сравнивает целочисленную ошибку с 0                      |
| При превышении порога корректирует координату и сбрасывает | При превышении порога корректирует координату и уменьшает ошибку на целое число |
| Требует операций с плавающей точкой (деление, сравнение)   | Использует только целочисленные операции (сложение, вычитание, сравнение) |

---

### Краткий комментарий

- В **без оптимизаций** варианте мы явно работаем с дробными числами и делением, что требует более дорогих вычислений.
- В **алгоритме Брезенхема** дробные операции заменены на умножение и целочисленные прибавления/вычитания, что значительно ускоряет работу и упрощает реализацию.
- Логика выбора следующего пикселя осталась той же — шаг по большей оси всегда на 1, а шаг по меньшей оси — условный, основанный на накопленной ошибке.
