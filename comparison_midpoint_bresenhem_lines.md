# Сравнение midpoint и Bresenham алгоритмов для растеризации прямых линий

Наглядное сопоставление ключевых строчек двух вариантов алгоритма построения линии: **без оптимизаций (с дробными вычислениями)** и **с оптимизациями (алгоритм Брезенхема с целочисленными вычислениями)**. Это поможет визуально увидеть, как именно происходит переход от "простой" реализации к эффективной.

---

### 1. Инициализация

| без оптимизаций (с дробями)                     | С оптимизациями (целочисленный Брезенхем)              |
|-------------------------------------------------|--------------------------------------------------------|
| `deltax = abs(x1 - x0)`                         | `deltaX = abs(x1 - x0)`                                |
| `deltay = abs(y1 - y0)`                         | `deltaY = abs(y1 - y0)`                                |
| `acc = 0.0`  // накопленная ошибка (fractional) | `error = 2 * deltaY - deltaX`  // целочисленная ошибка |
| `x = x0`                                        | `x = x0`                                               |
| `y = y0`                                        | `y = y0`                                               |


### 2. Основной цикл (движение по большей оси)

Для каждого шага по X (если `deltaX > deltaY`):

| Без оптимизаций (с дробями)                                | С оптимизациями (целочисленный Брезенхем)                    |
|------------------------------------------------------------|--------------------------------------------------------------|
| `x += signX`                                               | `x += signX`                                                 |
| `acc += deltaY / deltaX`  // добавляем дробное приращение  | `error += 2 * deltaY`  // добавляем целочисленное приращение |
| `if acc >= 0.5:`                                           | `if error > 0:`                                              |
| &nbsp;&nbsp;`y += signY`                                   | &nbsp;&nbsp;`y += signY`                                     |
| &nbsp;&nbsp;`acc -= 1.0`  // сбрасываем накопленную ошибку | &nbsp;&nbsp;`error -= 2 * deltaX`  // корректируем ошибку    |
| `plot(x, y)`                                               | `plot(x, y)`                                                 |

Для каждого шага по Y (если `deltaY > deltaX`):

| Без оптимизаций (с дробями) | С оптимизациями (целочисленный Брезенхем) |
|-----------------------------|-------------------------------------------|
| `y += signY`                | `y += signY`                              |
| `acc += deltaX / deltaY`    | `error += 2 * deltaX`                     |
| `if acc >= 0.5:`            | `if error > 0:`                           |
| &nbsp;&nbsp;`x += signX`    | &nbsp;&nbsp;`x += signX`                  |
| &nbsp;&nbsp;`acc -= 1.0`    | &nbsp;&nbsp;`error -= 2 * deltaY`         |
| `plot(x, y)`                | `plot(x, y)`                              |

### 3. Итоговое сравнение

| Что делает без оптимизаций?                                | Что делает с оптимизациями?                                                     |
|------------------------------------------------------------|---------------------------------------------------------------------------------|
| Использует дробные приращения `acc += deltaY / deltaX`     | Использует целочисленную ошибку `error += 2 * deltaY`                           |
| Сравнивает накопленную дробную ошибку с 0.5                | Сравнивает целочисленную ошибку с 0                                             |
| При превышении порога корректирует координату и сбрасывает | При превышении порога корректирует координату и уменьшает ошибку на целое число |
| Требует операций с плавающей точкой (деление, сравнение)   | Использует только целочисленные операции (сложение, вычитание, сравнение)       |

---

### Краткий комментарий

* В варианте **без оптимизаций** мы явно работаем с дробными числами и делением, что требует более дорогих вычислений.
* В **алгоритме Брезенхема** дробные операции заменены на умножение и целочисленные прибавления/вычитания, что значительно ускоряет работу и упрощает реализацию.
* Логика выбора следующего пикселя осталась той же — шаг по большей оси всегда на 1, а шаг по меньшей оси — условный, основанный на накопленной ошибке.
