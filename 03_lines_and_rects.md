<!--- file: 03_lines_and_rects.md --->

[[ Оглавление ]](README.md)

# Урок №3: Рисование линий и прямоугольников — первые шаги в растеризации

## Введение: Пиксель — кирпичик графики

На прошлом уроке мы создали нашу собственную графическую библиотеку — класс `GC`, который даёт нам прямой доступ к буферу пикселей через объект `ImageData`. Его метод `putPixel` — **единственный примитив, который нам действительно нужен** для реализации всех последующих алгоритмов. Всё остальное — это лишь умные способы вызывать этот метод много раз, в правильном порядке и с правильными параметрами.

Сегодня мы начнём строить поверх этого фундамента — шаг за шагом, линия за линией, фигура за фигурой. И первое, что сделает наш код удобнее — это работа с цветом.

### Улучшаем архитектуру: добавляем класс `ColorRGBA`

Вместо того чтобы передавать четыре числа (R, G, B, A) в каждый метод, мы создадим класс `ColorRGBA`, который объединит их в один логический объект. Это не просто удобство — это **инкапсуляция**, один из ключевых принципов объектно-ориентированного программирования. Мы скрываем детали представления цвета и работаем с ним как с единым понятием.

```javascript
class ColorRGBA {

    constructor(r = 255, g = 255, b = 255, a = 255) {
        const { max, min } = Math
        this.r = max(0, min(255, r)) // Ограничиваем диапазон
        this.g = max(0, min(255, g))
        this.b = max(0, min(255, b))
        this.a = max(0, min(255, a))
    }

    // Удобные статические цвета
    static get Black()   { return new ColorRGBA(0,     0,   0) }
    static get White()   { return new ColorRGBA(255, 255, 255) }
    static get Red()     { return new ColorRGBA(255,   0,   0) }
    static get Green()   { return new ColorRGBA(  0, 255,   0) }
    static get Blue()    { return new ColorRGBA(  0,   0, 255) }
    static get Yellow()  { return new ColorRGBA(255, 255,   0) }
    static get Magenta() { return new ColorRGBA(255,   0, 255) }
    static get Cyan()    { return new ColorRGBA(  0, 255, 255) }
}
```

> Такой подход сделает код чище, понятнее и легче для расширения — например, в будущем можно будет добавить методы для смешивания цветов, конвертации в другие модели (HSV, HSL) и т.д.

### Обновляем `GC.putPixel` — принимаем объект `ColorRGBA`

Теперь перепишем метод `putPixel`, чтобы он работал с объектом `ColorRGBA`. Это упростит интерфейс и сделает его более выразительным.

```javascript
class GC {

    constructor(width, height) {
        // ... предыдущая инициализация (canvas, ctx, imageData, data) ...
    }

    // Обновлённый метод: принимает объект ColorRGBA
    putPixel(x, y, color) {
        if (x < 0 || y < 0 || x >= this.canvas.width || y >= this.canvas.height) return
        const index = (y * this.canvas.width + x) * 4
        this.data[index]     = color.r
        this.data[index + 1] = color.g
        this.data[index + 2] = color.b
        this.data[index + 3] = color.a
    }

    clear(r = 0, g = 0, b = 0, a = 255) {
        // ... остаётся без изменений (можно тоже обновить позже) ...
    }

    blit() {
        // ... без изменений ...
    }
}
```

Теперь вместо `gc.putPixel(100, 100, 255, 0, 0)` мы пишем `gc.putPixel(100, 100, ColorRGBA.Red)` — короче, понятнее и выразительнее.

## Рисуем первые линии: горизонтальные и вертикальные

Начнём с самого простого — линий, параллельных осям координат. Это базовые строительные блоки, на которых будет держаться всё дальнейшее.

### Горизонтальная линия (hline)

Чтобы нарисовать горизонтальную линию, нужно закрасить пиксели **подряд по X**, при фиксированном Y.

```javascript
class GC {
    // ... предыдущие методы ...

    hline(x1, x2, y, color) {
        for (let x = x1; x <= x2; ++x) {
            this.putPixel(x, y, color)
        }
    }
}
```

### Вертикальная линия (vline)

Для вертикальной линии — **подряд по Y**, при фиксированном X.

```javascript
class GC {
    // ... предыдущие методы ...

    vline(x, y1, y2, color) {
        for (let y = y1; y <= y2; ++y) {
            this.putPixel(x, y, color)
        }
    }
}
```

> Почему это важно? Потому что **все сложные фигуры строятся из таких простых примитивов**. Освоив их, вы освоите основу растеризации.

### Добавляем диагонали: линии под 45°

Следующий шаг — линии под углом 45°. Здесь каждый следующий пиксель смещается **и по X, и по Y на 1**. Это значит, что в массиве `data` индекс увеличивается на `(width + 1) * 4` или `(width - 1) * 4` — в зависимости от направления.

```javascript
class GC {
    // ... предыдущие методы ...

    dline(x1, y1, x2, y2, color) {
        const dx = x2 > x1 ? 1 : -1 // Направление по X
        const dy = y2 > y1 ? 1 : -1 // Направление по Y
        let x = x1, y = y1

        // Пока не вышли за конечную точку
        while (x !== x2 + dx && y !== y2 + dy) {
            this.putPixel(x, y, color)
            x += dx
            y += dy
        }
    }
}
```

Пример использования:

```javascript
gc.dline(50,  50, 150, 150, ColorRGBA.Yellow)  // ↘ жёлтая
gc.dline(200, 50, 100, 150, ColorRGBA.Magenta) // ↙ пурпурная
```

## Объединяем всё в универсальный метод `line`

Теперь создадим метод `line`, который будет автоматически выбирать подходящий алгоритм — пока только для горизонтальных, вертикальных и диагональных линий.

```javascript
class GC {
    // ... предыдущие методы ...

    line(x1, y1, x2, y2, color = ColorRGBA.White) {
        const { min, max, abs } = Math 

        if (x1 === x2) {
            this.vline(x1, min(y1, y2), max(y1, y2), color)
            return
        }

        if (y1 === y2) {
            this.hline(min(x1, x2), max(x1, x2), y1, color)
            return
        }

        if (abs(x2 - x1) === abs(y2 - y1)) {
            this.dline(x1, y1, x2, y2, color)
            return
        }

        throw new Error(
            "Линия под произвольным углом пока не поддерживается. Продолжим в следующих уроках!")
    }
}
```

> Это временное ограничение. Уже в следующем уроке мы реализуем **алгоритм Брезенхема** — который научит нас рисовать линии под любым углом, используя только целочисленную арифметику и минимум операций.

## Рисуем прямоугольники и квадраты

Прямоугольник — это просто несколько горизонтальных (или вертикальных) линий, нарисованных одна под другой. Это естественное расширение того, что мы уже умеем.

### Заполненный прямоугольник

```javascript
class GC {
    // ... предыдущие методы ...

    fillRect(x, y, width, height, color) {
        for (let dy = 0; dy < height; ++dy) {
            this.hline(x, x + width - 1, y + dy, color)
        }
    }
}
```

### Контур прямоугольника

```javascript
class GC {
    // ... предыдущие методы ...

    drawRect(x, y, width, height, color) {
        this.hline(x, x + width - 1, y, color)              // Верх
        this.hline(x, x + width - 1, y + height - 1, color) // Низ
        this.vline(x, y, y + height - 1, color)             // Лево
        this.vline(x + width - 1, y, y + height - 1, color) // Право
    }
}
```

Пример:

```javascript
gc.fillRect(100, 100, 80, 60, new ColorRGBA(255, 100, 100)) // Розовый
gc.drawRect(200, 100, 80, 60, ColorRGBA.Blue)               // Синий контур
```

## Добавляем класс `Vec2` — двумерный вектор

Чтобы упростить работу с координатами, создадим простой класс `Vec2`. Он будет хранить X и Y, и предоставлять удобные методы для будущих преобразований.

```javascript
class Vec2 {

    constructor(x = 0, y = 0) {
        this.x = x
        this.y = y
    }

    toArray() {
        return [this.x, this.y]
    }
}
```

> Зачем это? Потому что в графике постоянно приходится работать с векторами — для движения, направлений, нормалей, преобразований. Лучше начать использовать их с самого начала — это подготовит вас к более сложным темам: анимациям, камере, 3D.


## Интерактивность: рисование по движению мыши

Теперь сделаем холст интерактивным — будем ставить точку каждый раз, когда мышь движется. Это не только весело, но и полезно — вы сразу видите результат своих действий.

```javascript
// Создаём GC и получаем ссылку на canvas
const gc = new GC(800, 600)
const canvas = gc.canvas // Сохраняем для обработчика

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top

    // Генерируем случайный цвет
    const color = new ColorRGBA(
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        Math.floor(Math.random() * 256),
        200 // Полупрозрачность
    )

    gc.putPixel(x, y, color)
})

// Игровой цикл
function gameLoop() {
    gc.blit()
    requestAnimationFrame(gameLoop)
}
requestAnimationFrame(gameLoop)
```

> Совет: чтобы точки не «засоряли» экран, можно добавить полупрозрачность (`a = 128`) или очищать холст раз в секунду — попробуйте оба варианта и почувствуйте разницу.


## Добавляем FPS-счётчик

Чтобы оценивать производительность наших экспериментов, добавим простой счётчик кадров в секунду — `FPS`.

```javascript
class FPS {

    constructor() {
        this.lastTime = performance.now()
        this.count = 0
        this.value = 0
    }

    update(timestamp) {
        ++this.count
        const elapsed = timestamp - this.lastTime
        if (elapsed > 1000) {
            this.value = Math.round((this.count * 1000) / elapsed)
            this.count = 0
            this.lastTime = timestamp
        }
    }
}
```

Использование в игровом цикле:

```javascript
const fps = new FPS()

function gameLoop(timestamp) {
    fps.update(timestamp)

    gc.clear(0, 0, 0)

    // Рисуем тестовые фигуры
    gc.line(50, 50, 200,  50, ColorRGBA.Yellow)
    gc.line(50, 50,  50, 200, ColorRGBA.Magenta)
    gc.dline(100, 100, 180, 180, ColorRGBA.Cyan)
    gc.fillRect(300, 100, 50, 50, ColorRGBA.Red)

    // Отображаем FPS
    gc.ctx.fillStyle = 'white'
    gc.ctx.font = '16px Monospace'
    gc.ctx.fillText(`FPS: ${fps.value}`, 10, 20)

    gc.blit()
    requestAnimationFrame(gameLoop)
}

requestAnimationFrame(gameLoop)
```

## Заключение: Простота, логика и следующий шаг

Сегодня мы прошли путь от одного пикселя — до целых фигур, управляемых мышью, с отображением производительности. Мы не использовали никакой «магии» — только логику, циклы и массивы. И именно так строится вся компьютерная графика: **из простых, понятных шагов складывается сложное и красивое**.

Конечно, пока наши линии умеют рисоваться только под определёнными углами. Но это не ограничение — это **ступенька**. В следующем уроке мы изучим один из самых элегантных алгоритмов в графике — **алгоритм Брезенхема**. Он покажет, как с помощью простой целочисленной арифметики можно рисовать идеальные линии под любым углом — быстро, точно и без ошибок.

Этот урок — начало нашего большого путешествия. Каждый пиксель, каждая линия — это кирпичик в фундаменте понимания. Не спешите. Поэкспериментируйте с кодом. Попробуйте нарисовать домик из прямоугольников или разноцветную сетку из линий. Почувствуйте, как ваши команды превращаются в изображение. Это магия, в основе которой лежит чистая логика. И вы уже прикоснулись к ней.

[[ Урок №2: Инструментарий. Canvas 2D и создание своей базовой графической библиотеки. ]](02_canvas_2d.md)  
